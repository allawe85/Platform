@page "/hierarchies"
@using Platform.Blazor.Pages.Hierarchies.Components
@using Platform.Blazor.Services.Auth
@using Platform.Blazor.Services.Hierarchies
@using Platform.Data.DTOs
@inject IHierarchiesService HierarchiesService
@inject IDialogService DialogService
@inject ISnackbar Snackbar

<MudText Typo="Typo.h5" Class="mb-4">Hierarchies</MudText>

<MudPaper Class="pa-4" Style="overflow-x: auto;">
    <MudToolBar>
        <MudText Typo="Typo.h6">Organization Chart</MudText>
        <MudSpacer />
        <MudButton Variant="Variant.Filled" Color="Color.Primary" OnClick="AddRootHierarchy" Class="mr-2">Add Root</MudButton>
        <MudButton Variant="Variant.Filled" Color="Color.Secondary" OnClick="AddChildHierarchy" Disabled="@(_selectedHierarchy == null)">Add Child</MudButton>
        <MudIconButton Icon="@Icons.Material.Filled.Edit" Color="Color.Default" OnClick="EditSelectedHierarchy" Disabled="@(_selectedHierarchy == null)" />
        <MudIconButton Icon="@Icons.Material.Filled.Delete" Color="Color.Error" OnClick="DeleteSelectedHierarchy" Disabled="@(_selectedHierarchy == null)" />
    </MudToolBar>

    @if (_loading)
    {
        <MudProgressCircular Indeterminate="true" Class="ma-4" />
    }
    else
    {
        <div class="org-tree">
            <ul>
               @RenderTree(TreeRoots)
            </ul>
        </div>
        
        @if (TreeRoots.Count == 0)
        {
             <MudText Class="ma-4">No hierarchies found. Add a root hierarchy to get started.</MudText>
        }
    }
</MudPaper>

<MudOverlay @bind-Visible="_showDialog" DarkBackground="true" AutoClose="false" ZIndex="9999">
    <MudPaper Class="pa-4" Style="width: 400px; max-width: 90vw;">
        <MudText Typo="Typo.h6" Class="mb-4">@_dialogTitle</MudText>
        <MudStack Spacing="2">
            <MudTextField Label="Name" @bind-Value="_currentHierarchy.Name" For="@(() => _currentHierarchy.Name)" />
            <MudTextField Label="Name (Arabic)" @bind-Value="_currentHierarchy.NameAr" For="@(() => _currentHierarchy.NameAr)" />
            
            <MudSelect T="int" Label="Hierarchy Level" @bind-Value="_currentHierarchy.HierarchyLevelId" AnchorOrigin="Origin.BottomCenter">
                @foreach (var level in Levels)
                {
                    <MudSelectItem Value="@level.Id">@level.Name</MudSelectItem>
                }
            </MudSelect>

            <MudSelect T="int" Label="Parent" @bind-Value="_currentHierarchy.ParentId" AnchorOrigin="Origin.BottomCenter">
                <MudSelectItem Value="0">Root</MudSelectItem>
                @foreach (var h in HierarchyList.Where(x => x.Id != _currentHierarchy.Id)) 
                {
                    <MudSelectItem Value="@h.Id">@h.Name</MudSelectItem>
                }
            </MudSelect>
        </MudStack>
        <MudStack Row="true" Justify="Justify.FlexEnd" Class="mt-4">
            <MudButton OnClick="CancelDialog">Cancel</MudButton>
            <MudButton Color="Color.Primary" Variant="Variant.Filled" OnClick="SubmitHierarchy">Save</MudButton>
        </MudStack>
    </MudPaper>
</MudOverlay>

@code {
    private List<Hierarchy> HierarchyList = new();
    private List<Hierarchy> TreeRoots = new();
    private List<HierarchyLevel> Levels = new();
    private bool _loading = true;

    // Dialog State
    private bool _showDialog;
    private Hierarchy _currentHierarchy = new();
    private string _dialogTitle = "Add Hierarchy";
    private bool _isEdit = false;
    
    // Selection
    private Hierarchy? _selectedHierarchy;

    protected override async Task OnInitializedAsync()
    {
        await LoadHierarchies();
        await LoadLevels();
    }

    private async Task LoadHierarchies()
    {
        _loading = true;
        try
        {
            HierarchyList = await HierarchiesService.GetHierarchiesAsync();
            BuildTree();
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Error loading hierarchies: {ex.Message}", Severity.Error);
        }
        finally
        {
            _loading = false;
        }
    }
    
    private void BuildTree()
    {
         foreach(var item in HierarchyList) item.Children.Clear();

         TreeRoots = HierarchyList.Where(x => x.ParentId == 0).ToList();
         
         foreach(var item in HierarchyList)
         {
             if (item.ParentId != 0)
             {
                 var parent = HierarchyList.FirstOrDefault(x => x.Id == item.ParentId);
                 if (parent != null)
                 {
                     parent.Children.Add(item);
                 }
                 else 
                 {
                     if (!TreeRoots.Contains(item))
                        TreeRoots.Add(item);
                 }
             }
         }
    }

    private async Task LoadLevels()
    {
        try
        {
            Levels = await HierarchiesService.GetLevelsAsync();
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Error loading levels: {ex.Message}", Severity.Error);
        }
    }

    private void AddRootHierarchy()
    {
        _currentHierarchy = new Hierarchy { ParentId = 0 };
        _dialogTitle = "Add Root Hierarchy";
        _isEdit = false;
        _showDialog = true;
    }

    private void AddChildHierarchy()
    {
        if (_selectedHierarchy == null) return;
        
        _currentHierarchy = new Hierarchy { ParentId = _selectedHierarchy.Id };
        _dialogTitle = $"Add Child to {_selectedHierarchy.Name}";
        _isEdit = false;
        _showDialog = true;
    }

    private void EditSelectedHierarchy()
    {
        if (_selectedHierarchy == null) return;
        EditHierarchy(_selectedHierarchy);
    }
    
    private void DeleteSelectedHierarchy()
    {
        if (_selectedHierarchy == null) return;
        DeleteHierarchy(_selectedHierarchy);
    }

    private void EditHierarchy(Hierarchy hierarchy)
    {
        _currentHierarchy = new Hierarchy { 
            Id = hierarchy.Id, 
            Name = hierarchy.Name, 
            NameAr = hierarchy.NameAr,
            HierarchyLevelId = hierarchy.HierarchyLevelId,
            ParentId = hierarchy.ParentId
        };
        _dialogTitle = "Edit Hierarchy";
        _isEdit = true;
        _showDialog = true;
    }

    private void CancelDialog()
    {
        _showDialog = false;
    }

    private async Task SubmitHierarchy()
    {
        await SaveHierarchy(_currentHierarchy);
    }

    private async Task SaveHierarchy(Hierarchy hierarchy)
    {
        try
        {
            if (_isEdit)
            {
                await HierarchiesService.UpdateHierarchyAsync(hierarchy.Id, hierarchy);
                Snackbar.Add("Hierarchy updated", Severity.Success);
            }
            else
            {
                await HierarchiesService.CreateHierarchyAsync(hierarchy);
                Snackbar.Add("Hierarchy created", Severity.Success);
            }
            _showDialog = false;
            await LoadHierarchies(); 
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Error saving hierarchy: {ex.Message}", Severity.Error);
        }
    }

    private async Task DeleteHierarchy(Hierarchy hierarchy)
    {
        bool? result = await DialogService.ShowMessageBox(
            "Warning", 
            $"Deleting {hierarchy.Name} can not be undone!", 
            yesText:"Delete!", cancelText:"Cancel");

        if (result == true)
        {
            try
            {
                await HierarchiesService.DeleteHierarchyAsync(hierarchy.Id);
                Snackbar.Add("Hierarchy deleted", Severity.Success);
                await LoadHierarchies();
                _selectedHierarchy = null; 
            }
            catch (Exception ex)
            {
                Snackbar.Add($"Error deleting hierarchy: {ex.Message}", Severity.Error);
            }
        }
    }

    private void OnSelectNode(Hierarchy node)
    {
        _selectedHierarchy = node;
    }

    // Recursively render Nodes as <li> with <div class="node-card">
    private RenderFragment RenderTree(List<Hierarchy> nodes) => __builder =>
    {
        foreach (var node in nodes)
        {
            <li>
                <div class="@GetNodeClass(node)" @onclick="() => OnSelectNode(node)">
                    <div class="node-title">@node.Name</div>
                    <div class="node-title">@node.NameAr</div>
                    <div class="node-subtitle">@(node.HierarchyLevel?.Name ?? "")</div>
                </div>
                @if (node.Children != null && node.Children.Count > 0)
                {
                    <ul>
                      @RenderTree(node.Children)
                    </ul>
                }
            </li>
        }
    };

    private string GetNodeClass(Hierarchy node)
    {
        var css = "node-card";
        if (_selectedHierarchy != null && _selectedHierarchy.Id == node.Id)
            css += " selected";
        return css;
    }
}
