@using Platform.Data.DTOs
@using Platform.Blazor.Pages.Hierarchies.Components
@inject IJSRuntime JSRuntime

<div class="@($"chart-container-scroll {(IsDarkMode ? "dark-theme" : "light-theme")}")" @ref="_chartContainer">
    <div class="chart-pan-wrapper" @ref="_panContainer">
        <div class="chart-scale-wrapper" style="transform: scale(@ZoomLevel.ToString(System.Globalization.CultureInfo.InvariantCulture)); transform-origin: top center;">
            <div class="org-tree">
                <ul>
                    @if (Roots != null)
                    {
                         @RenderChartTree(Roots)
                    }
                </ul>
            </div>
        </div>
    </div>
</div>

@code {
    [Parameter] public List<Hierarchy> Roots { get; set; } = new();
    [Parameter] public Dictionary<int, string> LevelColors { get; set; } = new();
    [Parameter] public bool IsDarkMode { get; set; }
    [Parameter] public int? SelectedNodeId { get; set; }
    [Parameter] public bool ReadOnly { get; set; } = false;
    
    [Parameter] public EventCallback<Hierarchy> OnNodeSelect { get; set; }
    [Parameter] public EventCallback<Hierarchy> OnAddChild { get; set; }
    [Parameter] public EventCallback<Hierarchy> OnEdit { get; set; }
    [Parameter] public EventCallback<Hierarchy> OnDelete { get; set; }
    
    // Zoom control exposed or handled internally? 
    // The user wants zoom in the standalone view too.
    // The Toolbar in Hierarchies.razor controls zoom.
    // Ideally this component should accept ZoomLevel.
    [Parameter] public double ZoomLevel { get; set; } = 1.0;
    [Parameter] public EventCallback<double> ZoomLevelChanged { get; set; }

    private ElementReference _chartContainer;
    private ElementReference _panContainer;
    private IJSObjectReference? _chartModule;
    private DotNetObjectReference<HierarchyChart>? _dotNetHelper;
    private bool _eventsActive = false;

    // We can't use OnAfterRenderAsync(firstRender) blindly if the component is re-used or parameters change.
    // But for now setup seems consistent with previous logic.
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender || _chartModule == null)
        {
            try 
            {
                _chartModule = await JSRuntime.InvokeAsync<IJSObjectReference>("import", "./js/charts.js");
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Failed to load charts.js: {ex.Message}");
            }
        }

        if (_chartModule != null && !_eventsActive)
        {
             if (_dotNetHelper == null) _dotNetHelper = DotNetObjectReference.Create(this);
             await _chartModule.InvokeVoidAsync("initChartEvents", _chartContainer, _panContainer, _dotNetHelper);
             _eventsActive = true;
             await Task.Delay(150);
             await CenterView();
        }
    }

    public async Task CenterView(int? nodeId = null)
    {
        if (_chartModule != null)
        {
            string? selector = nodeId.HasValue ? $"#node-{nodeId.Value}" : null;
            await _chartModule.InvokeVoidAsync("centerElement", _chartContainer, _panContainer, selector);
        }
    }

    [JSInvokable]
    public async Task OnZoom(double delta)
    {
        double newZoom = ZoomLevel;
        if (delta > 0) newZoom = Math.Min(ZoomLevel + 0.1, 2.0);
        else newZoom = Math.Max(ZoomLevel - 0.1, 0.2);
        
        if (newZoom != ZoomLevel)
        {
            ZoomLevel = newZoom;
            await ZoomLevelChanged.InvokeAsync(ZoomLevel);
            StateHasChanged(); // Ensure UI updates
        }
    }

    public async ValueTask DisposeAsync()
    {
        try {
            if (_chartModule != null)
            {
                if (_eventsActive) // Check if valid
                   await _chartModule.InvokeVoidAsync("stopChartEvents", _chartContainer);
                
                await _chartModule.DisposeAsync();
            }
            _dotNetHelper?.Dispose();
        } catch {} 
    }

    private RenderFragment RenderChartTree(List<Hierarchy> nodes) => __builder =>
    {
        foreach (var node in nodes)
        {
            <li>
                <div id="@($"node-{node.Id}")" 
                     class="@GetNodeClass(node)" 
                     style="@($"--level-color: {GetLevelColorImpl(node.HierarchyLevelId)};")"
                     @onclick="() => OnNodeSelect.InvokeAsync(node)"
                     @onclick:stopPropagation="true">
                    
                    <div class="accent-bar"></div>
                    <div class="node-content">
                        <div class="node-title">
                            @(System.Globalization.CultureInfo.CurrentUICulture.Name.StartsWith("ar") && !string.IsNullOrEmpty(node.NameAr) ? node.NameAr : node.Name)
                        </div>
                        <div class="node-subtitle">
                             @(System.Globalization.CultureInfo.CurrentUICulture.Name.StartsWith("ar") && !string.IsNullOrEmpty(node.HierarchyLevel?.NameAr) ? node.HierarchyLevel.NameAr : node.HierarchyLevel?.Name ?? "")
                        </div>
                    </div>
                    
                    @if (!ReadOnly)
                    {
                    <div class="node-actions">
                         <MudIconButton Icon="@Icons.Material.Filled.Add" Size="Size.Small" 
                                        Variant="Variant.Filled" Color="Color.Surface" 
                                        OnClick="@(() => OnAddChild.InvokeAsync(node))" Title="Add Child" />
                         <MudIconButton Icon="@Icons.Material.Filled.Edit" Size="Size.Small" 
                                        Variant="Variant.Filled" Color="Color.Surface" 
                                        OnClick="@(() => OnEdit.InvokeAsync(node))" Title="Edit" />
                         <MudIconButton Icon="@Icons.Material.Filled.Delete" Size="Size.Small" 
                                        Variant="Variant.Filled" Color="Color.Error" 
                                        OnClick="@(() => OnDelete.InvokeAsync(node))" Title="Delete" />
                    </div>
                    }
                </div>
                @if (node.Children != null && node.Children.Count > 0)
                {
                    <ul>
                      @RenderChartTree(node.Children)
                    </ul>
                }
            </li>
        }
    };

    private string GetNodeClass(Hierarchy node)
    {
        string selectedClass = (SelectedNodeId == node.Id) ? "selected" : "";
        return $"node-card {(IsDarkMode ? "dark-theme" : "light-theme")} {selectedClass}"; 
    }

    private string GetLevelColorImpl(int levelId) 
    {
        return LevelColors.ContainsKey(levelId) ? LevelColors[levelId] : "#999"; 
    }
}
